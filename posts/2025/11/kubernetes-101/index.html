<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kubernetes 101 — Justine Longla T. DevOps Blog</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- SEO meta -->
  <meta name="description"
        content="A practical introduction to Kubernetes: pods, nodes, services, and why orchestration matters for real-world workloads." />
  <meta name="tags"
        content="kubernetes, containers, devops, orchestration, cloud" />

  <!-- Global blog styles -->
  <link rel="stylesheet" href="/assets/css/main.css" />
</head>

<body>
  <a class="skip" href="#content">Skip to content</a>

  <!-- Site header -->
  <header class="site-header">
    <div class="container header-row">
      <a class="brand" href="/">
        <img class="brand-logo" src="/logo.png" />
        <span class="brand-title">Justine Longla T. DevOps Blog</span>
      </a>

      <nav class="site-nav">
        <a href="/">Home</a>
        <a href="/blog/">All Blog Posts</a>
        <a href="/projects/">Projects</a>
      </nav>
    </div>
  </header>

  <!-- Main article -->
  <main id="content" class="container prose">

    <p class="post-meta">
      By Justine Longla · 3 min read ·
      <time datetime="2025-10-24">Oct 24, 2025</time>
    </p>

    <h1>Kubernetes 101</h1>

    <p>
      Kubernetes can look intimidating from the outside: YAML everywhere,
      clusters, pods, controllers, services, and a vocabulary that feels like a
      new language. But at its core, Kubernetes is simply an operating system
      for containers — a smart scheduler that keeps your applications running
      the way you declared they should.
    </p>

    <p>
      This post is a gentle introduction: just enough Kubernetes to understand
      how it fits into modern DevOps work and how it supports reliable delivery
      for real-world workloads.
    </p>

    <h2>From Servers to Containers to Clusters</h2>

    <p>
      Before Kubernetes, deploying an application meant thinking about servers:
      CPU, RAM, OS patches, and manual configuration. Containers simplified
      that story. They package code and dependencies into a portable unit that
      can run the same way on a laptop, a VM, or in the cloud.
    </p>

    <p>
      Kubernetes takes the next step: it manages <em>many</em> containers across
      a pool of machines, making the cluster behave like one logical platform.
      Instead of logging into servers, you declare the desired state — and
      Kubernetes does the heavy lifting to make reality match your declaration.
    </p>

    <h2>Key Building Blocks</h2>

    <h3>Pods</h3>

    <p>
      A <strong>Pod</strong> is the smallest deployable unit in Kubernetes. Most
      of the time, a pod runs a single container, but it can host a small group
      of tightly coupled containers that share storage and networking.
    </p>

    <p>
      You rarely manage individual pods by hand. Instead, you let controllers
      create and recreate pods for you.
    </p>

    <h3>Nodes</h3>

    <p>
      A <strong>Node</strong> is a worker machine in the cluster — a VM or
      physical host where pods actually run. Kubernetes schedules pods onto
      nodes based on available resources and placement rules.
    </p>

    <h3>Deployments</h3>

    <p>
      A <strong>Deployment</strong> describes how many replicas of an
      application you want and which container image they should use. If you
      say “run 3 replicas,” the deployment controller keeps three pods alive
      — replacing any pod that crashes or disappears.
    </p>

    <h3>Services</h3>

    <p>
      A <strong>Service</strong> gives your pods a stable network identity.
      Pods come and go, but the service IP or DNS name remains constant.
      Traffic is load-balanced across healthy pods behind the scenes.
    </p>

    <h2>Declarative, Not Manual</h2>

    <p>
      The real power of Kubernetes is its declarative model. Instead of running
      imperative commands like “start this container” or “restart that pod,”
      you describe the desired state in YAML:
    </p>

    <ul>
      <li>How many replicas you want</li>
      <li>Which container image and version to run</li>
      <li>What ports to expose</li>
      <li>What resources (CPU/RAM) to request or limit</li>
    </ul>

    <p>
      Kubernetes compares this desired state with the actual state of the
      cluster and continuously works to close the gap. This feedback loop is
      what makes rolling updates, self-healing, and automatic rescheduling
      possible.
    </p>

    <h2>Where Kubernetes Meets DevOps</h2>

    <p>
      In DevOps practice, Kubernetes becomes the execution layer for CI/CD:
    </p>

    <ul>
      <li>CI builds container images and pushes them to a registry.</li>
      <li>CD tools update Kubernetes manifests or Helm charts.</li>
      <li>Kubernetes rolls out the new version, monitors health, and rolls back if needed.</li>
    </ul>

    <p>
      When combined with good observability and disciplined pipelines, a
      Kubernetes cluster turns deployment from a risky event into a routine,
      repeatable operation.
    </p>

    <h2>Getting Comfortable With the Basics</h2>

    <p>
      You don’t need to learn every Kubernetes feature to be productive. If you
      understand pods, deployments, services, and the idea of declarative
      configuration, you already hold the core mental model.
    </p>

    <p>
      From there, you can gradually explore advanced topics like ingress
      controllers, autoscaling, namespaces, and multi-cluster setups — always
      anchored in the same foundation.
    </p>

    <p><strong>Kubernetes 101 is simple:</strong> containers plus orchestration plus
    a clear desired state. The rest is layering experience on top of those core
    ideas.</p>

  </main>

  <!-- Global footer -->
  <footer class="site-footer">
    <div class="container footer-grid">
      <div class="footer-left">
        <a class="brand small" href="/">
          <img class="brand-logo small" src="/logo.png" alt="Jutellane logo" />
          <span class="brand-title small">Justine Longla T. DevOps Blog</span>
        </a>

        <p class="copyright">
          © <span id="y"></span> <strong>Jutellane Solutions</strong>. All rights reserved.
        </p>
      </div>

      <nav class="footer-nav">
        <a href="/">Home</a>
        <a href="/blog/">All Blog Posts</a>
        <a href="/projects/">Projects</a>
      </nav>
    </div>

    <script>
      document.getElementById("y").textContent = new Date().getFullYear();
    </script>
  </footer>

</body>
</html>

