<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Observability Basics — Justine Longla T. DevOps Blog</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- SEO meta -->
  <meta name="description"
        content="An introduction to logs, metrics, and traces — the three pillars of observability and how they help you understand modern systems." />
  <meta name="tags"
        content="observability, logs, metrics, traces, devops, monitoring" />

  <!-- Global blog styles -->
  <link rel="stylesheet" href="/assets/css/main.css" />
</head>

<body>
  <a class="skip" href="#content">Skip to content</a>

  <!-- Site header -->
  <header class="site-header">
    <div class="container header-row">
      <a class="brand" href="/">
        <img class="brand-logo" src="/logo.png" alt="JustineLonglaT-Lane logo" />
        <span class="brand-title">Justine Longla T. DevOps Blog</span>
      </a>

      <nav class="site-nav">
        <a href="/">Home</a>
        <a href="/blog/">All Blog Posts</a>
        <a href="/projects/">Projects</a>
      </nav>
    </div>
  </header>

  <!-- Main article -->
  <main id="content" class="container prose">

    <p class="post-meta">
      By Justine Longla · 3 min read ·
      <time datetime="2025-11-12">Nov 12, 2025</time>
    </p>

    <h1>Observability Basics</h1>

    <p>
      Modern systems are no longer a single server in a corner of the data center.
      They are pipelines, services, queues, APIs, and background jobs, all moving
      together. When something goes wrong, you need more than a simple
      <strong>&ldquo;up or down&rdquo;</strong> dashboard. You need the system to
      explain itself.
    </p>

    <p>
      That is the promise of <strong>observability</strong>:
      the ability to understand what is happening inside a system
      just by looking at the signals it emits from the outside.
      At the foundation are three core building blocks:
      <strong>logs, metrics, and traces</strong>.
    </p>

    <h2>Why Observability Matters</h2>

    <p>
      In a small app, you can sometimes guess your way through a bug:
      restart a service, clear a cache, or redeploy and hope for the best.
      In larger systems, guesswork is expensive. Every deployment,
      every incident, and every performance regression needs to be handled
      with clarity and data.
    </p>

    <p>
      Observability gives you that clarity. When used well, it helps you:
    </p>

    <ul>
      <li>Detect problems before users feel them.</li>
      <li>Understand <em>where</em> an issue is coming from, not just that it exists.</li>
      <li>See the impact of changes across services and pipelines.</li>
      <li>Build confidence that your automation and releases behave as intended.</li>
    </ul>

    <p>
      The good news: you don’t have to start with an entire observability platform.
      You can begin with the three pillars and grow step by step.
    </p>

    <h2>Logs — The Story of Events</h2>

    <p>
      <strong>Logs</strong> are the narrative of your system.
      Each line is a short sentence describing something that happened:
      a request received, a job completed, a cache miss, a validation failure.
    </p>

    <p>
      Simple logs might look like free-form text, but they become much more
      powerful when they are structured. That means using a predictable
      format and including fields such as:
    </p>

    <ul>
      <li><code>timestamp</code> – when the event happened</li>
      <li><code>level</code> – info, warning, error, critical</li>
      <li><code>service</code> or <code>component</code> – where it happened</li>
      <li><code>correlationId</code> or <code>requestId</code> – to tie events together</li>
    </ul>

    <p>
      With consistent logs, you can filter, search, and correlate events
      across the entire stack — from the static-blog pipeline to APIs and
      background workers.
    </p>

    <h2>Metrics — The Health Dashboard</h2>

    <p>
      While logs tell detailed stories, <strong>metrics</strong> summarize trends.
      They are numeric time series that answer questions like:
      &ldquo;How many? How often? How long?&rdquo;
    </p>

    <p>Common DevOps metrics include:</p>

    <ul>
      <li>CPU and memory utilization</li>
      <li>Disk I/O and network throughput</li>
      <li>Request success rate and latency distribution</li>
      <li>Pipeline duration and failure frequency</li>
    </ul>

    <p>
      Metrics help you spot emerging issues before they become incidents:
      slow builds, noisy neighbors, or a new deployment that quietly
      doubled error rates. They are ideal for alerting, SLOs,
      and executive dashboards.
    </p>

    <h2>Traces — Following a Request End to End</h2>

    <p>
      <strong>Traces</strong> connect the dots.
      A trace shows how a single request flows through the system —
      across services, queues, caches, databases, and external APIs.
      Each hop is recorded as a <em>span</em> with timing and metadata.
    </p>

    <p>
      When a request is slow or fails, traces help answer questions such as:
    </p>

    <ul>
      <li>Where is the request spending most of its time?</li>
      <li>Which upstream or downstream dependency is causing the slowdown?</li>
      <li>Is the problem isolated to one path, or does it affect many flows?</li>
    </ul>

    <p>
      In distributed systems and multi-step pipelines,
      traces act like a GPS route: you can replay the journey and
      see every turn the request took along the way.
    </p>

    <h2>Bringing Logs, Metrics, and Traces Together</h2>

    <p>
      Each pillar has its strength:
      logs provide detail, metrics show trends, and traces reveal journeys.
      The real power of observability appears when they work together.
    </p>

    <p>
      A typical flow for a JustineLonglaT-Lane project might look like this:
    </p>

    <ul>
      <li>A CI job starts and emits structured logs for each step.</li>
      <li>Metrics track overall build duration and success rate.</li>
      <li>Traces link the build to downstream actions such as deployments or cache warm-ups.</li>
    </ul>

    <p>
      When something goes wrong, you can jump from a metric spike
      to the exact logs and traces for the affected window — no guessing, no hunting.
    </p>

    <h2>Getting Started With Observability</h2>

    <p>
      You do not need to implement everything at once.
      A practical starting point is:
    </p>

    <ol>
      <li>Standardize log formatting across scripts and services.</li>
      <li>Publish a small set of core metrics (success rates, durations, error counts).</li>
      <li>Introduce tracing for one or two critical paths.</li>
    </ol>

    <p>
      As your projects grow, observability becomes the foundation for
      safe automation, fast incident response, and confident experimentation.
    </p>

    <p>
      <strong>Observability basics are simple:</strong> capture meaningful signals,
      keep them consistent, and use them to ask better questions about your systems.
      Everything else builds on that core.
    </p>

  </main>

  <!-- Global footer -->
  <footer class="site-footer">
    <div class="container footer-grid">
      <div class="footer-left">
        <a class="brand small" href="/">
          <img class="brand-logo small" src="/logo.png" alt="JustineLonglaT-Lane logo" />
          <span class="brand-title small">Justine Longla T. DevOps Blog</span>
        </a>

        <p class="copyright">
          © <span id="y"></span> <strong>JustineLonglaT-Lane Consulting</strong>. All rights reserved.
        </p>
      </div>

      <nav class="footer-nav">
        <a href="/">Home</a>
        <a href="/blog/">All Blog Posts</a>
        <a href="/projects/">Projects</a>
      </nav>
    </div>

    <script>
      document.getElementById("y").textContent = new Date().getFullYear();
    </script>
  </footer>

</body>
</html>







